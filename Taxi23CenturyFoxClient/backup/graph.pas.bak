unit graph;


{$mode objfpc}{$H+}

interface

uses
  Dialogs, Classes, SysUtils, DataModule;

type
  matrix = array of array of integer;
  mass = array [1..100] of integer;
  endless = array of integer;

procedure FormAdjecencyMatrix (nodesCount: integer; var a: matrix);

function Dijkstra(var s: integer; param: string): mass;


implementation

procedure FormAdjecencyMatrix (nodesCount: integer; var a: matrix);
var i, j, id, n, m: integer;
const inf = 9999;
begin
  {Иницицализация всех возможных ребер}
  for i:=1 to nodesCount do
     for j:=1 to nodesCount do
        a[i][j] := inf;
  {Заполнение матрицы существующими ребрами}
  DataModule1.EdgesQuery.Close;
  DataModule1.EdgesQuery.Open;
  while not (DataModule1.EdgesQuery.EOF) do
     begin
         n := DataModule1.EdgesQueryfirst_node.Asinteger;
         m := DataModule1.EdgesQuerysecond_node.Asinteger;
         a[n][m] := DataModule1.EdgesQuerydistance.AsInteger;
         a[m][n] := DataModule1.EdgesQuerydistance.AsInteger;
         DataModule1.EdgesQuery.Next;
      end;
end;

function ExtractMin (d: mass; var Q: endless): integer;
const
  inf = 9999;
var i: integer;
    index, min: integer;
begin
   min := inf;
   for i:=0 to length(Q)-1 do
      if (d[Q[i]] < min) {and (d[Q[i]] <> 0)} then
         begin
            min := d[Q[i]];
            index := Q[i];
         end;
   i := 0;

   while (i < length(Q)) and (Q[i] <> index) do
      inc(i);
   if i < length(q) then
    begin
      Q[i] := Q[length(Q)-1];
      setlength(Q, length(Q)-1);
    end;

result := index;
end;

function Dijkstra(var s: integer; param: string): mass;
const
  inf = 9999;
var
    d, p: mass; //distance, previous
    q: endless; //queue
    i, curr, nodesCount: integer;
    a: matrix;
begin
      DataModule1.CountLocationsQuery.Open;
    nodesCount := DataModule1.CountLocationsQuery.FieldByName('nodesCount').AsInteger;
    setlength(a, nodesCount+1); // 0-я строка и столбец не будут учитываться
      for i:=1 to nodesCount do
         setlength(a[i], nodesCount+1);
    FormAdjecencyMatrix(nodesCount, a);

     for i:=1 to nodesCount do
         d[i] := inf;
     for i:=1 to nodesCount do
         p[i] := 0;
     d[s] := 0; //distance of current node S
     for i:=1 to nodesCount do
         begin
              setlength(q, length(q)+1);
              q[i-1] := i; //i-1
         end;
         while length(q) > 0 do
               begin
                    curr := ExtractMin(d, Q);
                    for i:=1 to nodesCount do
                        if(d[i] > d[curr] + a[curr][i]) then
                           begin
                                d[i] := d[curr] + a[curr][i];
                                p[i] := curr;
                           end;
               end;
     if param = 'distance' then
        Dijkstra := d
     else Dijkstra := p;
end;

end.

